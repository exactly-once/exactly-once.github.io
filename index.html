<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.126.1">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Exactly Once</title>
  <meta name="description" content="On distributed systems by [@SzymonPobiega](http://twitter.com/SzymonPobiega) and [@Masternak](http://twitter.com/Masternak)" />

  
  <link type="text/css" rel="stylesheet" href="https://exactly-once.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://exactly-once.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://exactly-once.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://exactly-once.github.io/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="https://exactly-once.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Exactly Once" />
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://exactly-once.github.io/"><h1>Exactly Once</h1></a>
      <p class="lead">
        On distributed systems by <a href="http://twitter.com/SzymonPobiega">@SzymonPobiega</a> and <a href="http://twitter.com/Masternak">@Masternak</a>
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://exactly-once.github.io/">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2024. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="posts">
<article class="post">
  <h1 class="post-title">
    <a href="https://exactly-once.github.io/posts/token-driven-processes/">Token-driven distributed business processes</a>
  </h1>
  <time datetime="2024-05-23T00:00:00Z" class="post-date">Thu, May 23, 2024</time>
  Long ago (1987) some industry thought leaders like Hector Garcia-Molina realized that transactions are not a suitable way of maintaining consistency of long-running processes. Despite this fact, the reliance on transactions for consistency of writes done across multiple processes over long timeframes continued with technologies such as Microsoft Distributed Transaction Coordinator or XA implementing the 2-phase commit protocol.
The most sophisticated (ab)use of distributed transaction technology was probably the WS-AtomicTransaction spec from 2004, which stood out as too enterprisey even compared to the other WS-* specifications.
  
  <div class="read-more-link">
    <a href="/posts/token-driven-processes/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://exactly-once.github.io/posts/exactly-once-http/">HTTP protocol for exactly-once processing</a>
  </h1>
  <time datetime="2021-04-26T00:00:00Z" class="post-date">Mon, Apr 26, 2021</time>
  This article proposes an HTTP-based protocol that can be used to ensure remote invocation is conducted exactly once. It is an adaptation of the token-based-deduplication idea described previously.
One of the most common system integration scenarios is executing a function remotely and fetching the result. It is easy if the target function is pure (does not have any side effects). But what if it does?
The basic building blocks of the HTTP protocol and REST approach are not enough to guarantee exactly-once execution in such a scenario.
  
  <div class="read-more-link">
    <a href="/posts/exactly-once-http/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://exactly-once.github.io/posts/side-effects/">Side effects</a>
  </h1>
  <time datetime="2021-01-21T00:00:00Z" class="post-date">Thu, Jan 21, 2021</time>
  Side effects In the previous post we introduced the token-based deduplication approach. It inverts the traditional principle of deduplication. Instead of dropping a message if another copy of that same message is known to have been processed, the token-based approach drops a message if there is no token for processing it. In other words it uses negative (token does not exist), rather than positive (processing information exists), proof of duplication.
  
  <div class="read-more-link">
    <a href="/posts/side-effects/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://exactly-once.github.io/posts/token-based-deduplication/">Token-based deduplication</a>
  </h1>
  <time datetime="2020-08-27T00:00:00Z" class="post-date">Thu, Aug 27, 2020</time>
  One problem left unsolved by our previous attempts at designing a deduplication solution is the non-deterministic nature of data eviction. We know we can&rsquo;t keep the deduplication data forever but when can we safely delete it? Unfortunately there is no good answer. The longer we keep the data, the less likely we are to miss a duplicate message. Fortunately there is a way to solve the problem.
When it&rsquo;s gone, it&rsquo;s gone So far our algorithms depended on the existence of information to be able to discard a duplicate message.
  
  <div class="read-more-link">
    <a href="/posts/token-based-deduplication/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://exactly-once.github.io/posts/improving-outbox/">Improving outbox</a>
  </h1>
  <time datetime="2020-07-24T00:00:00Z" class="post-date">Fri, Jul 24, 2020</time>
  In one of the previous posts we introduced the Outbox pattern. The Outbox implements the consistent messaging idea by storing the ID of the incoming message and the collection of outgoing messages in the outbox records inside the application database. The correctness of the Outbox behavior depends on the ability to tap into the application state change transaction. The big advantage of this pattern is its relative simplicity, compared to alternative solutions.
  
  <div class="read-more-link">
    <a href="/posts/improving-outbox/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://exactly-once.github.io/posts/model-checking-exactly-once/">Model checking exactly-once</a>
  </h1>
  <time datetime="2020-07-18T00:00:00Z" class="post-date">Sat, Jul 18, 2020</time>
  Designing distributed algorithms is a challenging task. It&rsquo;s not that hard to reason about &ldquo;happy paths&rdquo; and show that at least sometimes the algorithm does what we intended. Checking that it always behaves as expected is a completely different story.
By definition, any non-trivial distributed system is concurrent and fails partially. Both elements adding up to the combinatorial explosion of possible executions - too many to fit in a single person&rsquo;s head or analyze by hand.
  
  <div class="read-more-link">
    <a href="/posts/model-checking-exactly-once/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://exactly-once.github.io/posts/intuition/">Exactly-once intuition</a>
  </h1>
  <time datetime="2020-07-06T00:00:00Z" class="post-date">Mon, Jul 6, 2020</time>
  Distributed algorithms are difficult. If you find yourself struggling to understand one of them, we assure you &ndash; you are not alone. We have spent last couple of years researching ways to ensure exactly-once message processing in systems that exchange messages in an asynchronous and durable way (a.k.a. message queues) and you know what? We still struggle and make silly mistakes. The reason is that even a very simple distributed algorithm generates vast numbers of possible execution paths.
  
  <div class="read-more-link">
    <a href="/posts/intuition/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://exactly-once.github.io/posts/exactly-once-delivery/">Exactly-once message delivery</a>
  </h1>
  <time datetime="2020-05-20T00:00:00Z" class="post-date">Wed, May 20, 2020</time>
  It is widely known that exactly-once message delivery is impossible in a distributed system. But what is exactly-once delivery? To answer this question we need to first ask what do we understand as message delivery. This is not an easy task. In real life the receiving system is not a single blob of code. It consists of multiple layers. Is the message considered delivered when all its bytes are read from the network cable?
  
  <div class="read-more-link">
    <a href="/posts/exactly-once-delivery/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://exactly-once.github.io/posts/outbox/">Outbox</a>
  </h1>
  <time datetime="2020-03-06T00:00:00Z" class="post-date">Fri, Mar 6, 2020</time>
  In the previous post we have shown how consistent messaging can be implemented by storing point-in-time state snapshots and using these snapshots for publishing outgoing messages. We discussed some pros and cons of this approach. This time we will focus on the alternative approach which is based on storing the outgoing messages before they are dispatched.
Consistent messaging requires the ability to ensure exactly same side effects (in form of the outgoing messages) each time a copy of a given incoming message is processed.
  
  <div class="read-more-link">
    <a href="/posts/outbox/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://exactly-once.github.io/posts/state-based-consistent-messaging/">State-based consistent messaging</a>
  </h1>
  <time datetime="2020-03-02T00:00:00Z" class="post-date">Mon, Mar 2, 2020</time>
  In the previous posts, we described consistent messaging and justified its usefulness in building robust distributed systems. Enough with the theory, it&rsquo;s high time to show some code! First comes the state-based approach.
Context State-based consistent messaging comes with two requirements:
&ldquo;Point-in-time&rdquo; state availability - it&rsquo;s possible to restore any past version of the state. Deterministic message handling logic - for a set state and input message every handler execution gives the same result.
  
  <div class="read-more-link">
    <a href="/posts/state-based-consistent-messaging/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://exactly-once.github.io/posts/distributed-business-processes/">Distributed business processes</a>
  </h1>
  <time datetime="2020-01-21T00:00:00Z" class="post-date">Tue, Jan 21, 2020</time>
  In the previous post we explained what a messaging infrastructure is. We showed that it is necessarily a distributed thing with parts running in different processes. We&rsquo;ve seen the trade-offs involved in building the messaging infrastructure and what conditions must be met to guarantee consistent message processing on top of such infrastructure. This time we will explain why it is reasonable to expect that most line-of-business systems require a messaging infrastructure.
  
  <div class="read-more-link">
    <a href="/posts/distributed-business-processes/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://exactly-once.github.io/posts/messaging-infrastructure/">Messaging infrastructure</a>
  </h1>
  <time datetime="2019-11-19T00:00:00Z" class="post-date">Tue, Nov 19, 2019</time>
  The messaging infrastructure is all the components required to exchange messages between parts of the business logic code.
There are two parts to the messaging infrastructure. One is the message broker that manages the message queues (and possibly topics). The other equally important part consists of all the libraries running in the same process as the application logic, that expose the API for processing messages.
Whenever an application wants to send a message, it calls the in-process part of the messaging infrastructure which, in turn, communicates with the out-of-process part.
  
  <div class="read-more-link">
    <a href="/posts/messaging-infrastructure/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://exactly-once.github.io/posts/notes-on-2pc/">Notes on 2PC</a>
  </h1>
  <time datetime="2019-10-24T00:00:00Z" class="post-date">Thu, Oct 24, 2019</time>
  If there&rsquo;s a distributed protocol every software engineer knows it&rsquo;s Two-Phase Commit also know as 2PC. Although, in use for several decades1, it&rsquo;s been in steady decline mainly due to lack of support in cloud environments.
For quite some time it was a de-facto standard for building enterprise distributed systems. That said, with the cloud becoming the default deployment model, designers need to learn how to build reliable systems without it.
  
  <div class="read-more-link">
    <a href="/posts/notes-on-2pc/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://exactly-once.github.io/posts/consistent-state/">Consistent state</a>
  </h1>
  <time datetime="2019-10-11T00:00:00Z" class="post-date">Fri, Oct 11, 2019</time>
  In the previous post we talked about exactly-once processing looking at the endpoint from the outside. Here we will re-focus on an individual endpoint and see what exactly-once means for an endpoint&rsquo;s state.
It&rsquo;s not about the execution history Exactly-once spawned some heated debates in the past1 so let&rsquo;s make sure we make it clear what it means in our context - or more importantly what it doesn&rsquo;t. Here we talk about exactly-once processing not delivery, the two being quite different things.
  
  <div class="read-more-link">
    <a href="/posts/consistent-state/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://exactly-once.github.io/posts/sync-async-boundary/">Sync-async boundary</a>
  </h1>
  <time datetime="2019-09-19T00:00:00Z" class="post-date">Thu, Sep 19, 2019</time>
  If our experience in the IT industry has taught us anything it would be that drawing boundaries is the most important part of the design process. Boundaries are essential for understanding and communicating the design. The sync-async is an example of a boundary that is useful when designing distributed systems.
Purely sync The most popular technology for building synchronous systems is HTTP. Such systems often consist of multiple layers of HTTP endpoints.
  
  <div class="read-more-link">
    <a href="/posts/sync-async-boundary/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://exactly-once.github.io/posts/consistent-messaging/">Consistent messaging</a>
  </h1>
  <time datetime="2019-09-04T00:00:00Z" class="post-date">Wed, Sep 4, 2019</time>
  Modern messaging infrastructures offer delivery guarantees that make it non-trivial to build distributed systems. Robust solutions require a good understanding of what can and can&rsquo;t happen and how that affects business level behavior.
This post looks at the main challenges from the system consistency perspective and sketches possible solutions.
A system We will assume that systems in focus consist of endpoints, each owning a distinct piece of state. Every endpoint processes input messages, modifying internal state and producing output messages.
  
  <div class="read-more-link">
    <a href="/posts/consistent-messaging/">Read More…</a>
  </div>
  
</article>
</div>
    </main>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-147074711-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  </body>
</html>
