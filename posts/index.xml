<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Exactly Once</title>
    <link>https://exactly-once.github.io/posts/</link>
    <description>Recent content in Posts on Exactly Once</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 03 Feb 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://exactly-once.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>State-based consistent messaging</title>
      <link>https://exactly-once.github.io/posts/state-based-consistent-messaging/</link>
      <pubDate>Mon, 03 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://exactly-once.github.io/posts/state-based-consistent-messaging/</guid>
      <description>In the previous posts, we described consistent messaging and justified its usefulness in building robust distributed systems. Enough with the theory, it&amp;rsquo;s high time to show some code! First comes the state-based approach.
Context State-based consistent messaging comes with two requirements:
 &amp;ldquo;Point-in-time&amp;rdquo; state availability - it&amp;rsquo;s possible to restore any past version of the state. Deterministic message handling logic - for a set state and input message every handler execution gives the same result.</description>
    </item>
    
    <item>
      <title>Distributed business processes</title>
      <link>https://exactly-once.github.io/posts/distributed-business-processes/</link>
      <pubDate>Tue, 21 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://exactly-once.github.io/posts/distributed-business-processes/</guid>
      <description>In the previous post we explained what a messaging infrastructure is. We showed that it is necessarily a distributed thing with parts running in different processes. We&amp;rsquo;ve seen the trade-offs involved in building the messaging infrastructure and what conditions must be met to guarantee consistent message processing on top of such infrastructure. This time we will explain why it is reasonable to expect that most line-of-business systems require a messaging infrastructure.</description>
    </item>
    
    <item>
      <title>Messaging infrastructure</title>
      <link>https://exactly-once.github.io/posts/messaging-infrastructure/</link>
      <pubDate>Tue, 19 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://exactly-once.github.io/posts/messaging-infrastructure/</guid>
      <description>The messaging infrastructure is all the components required to exchange messages between parts of the business logic code.
There are two parts to the messaging infrastructure. One is the message broker that manages the message queues (and possibly topics). The other equally important part consists of all the libraries running in the same process as the application logic, that expose the API for processing messages.
Whenever an application wants to send a message, it calls the in-process part of the messaging infrastructure which, in turn, communicates with the out-of-process part.</description>
    </item>
    
    <item>
      <title>Notes on 2PC</title>
      <link>https://exactly-once.github.io/posts/notes-on-2pc/</link>
      <pubDate>Thu, 24 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://exactly-once.github.io/posts/notes-on-2pc/</guid>
      <description>If there&amp;rsquo;s a distributed protocol every software engineer knows it&amp;rsquo;s Two-Phase Commit also know as 2PC. Although, in use for several decades1, it&amp;rsquo;s been in steady decline mainly due to lack of support in cloud environments.
For quite some time it was a de-facto standard for building enterprise distributed systems. That said, with the cloud becoming the default deployment model, designers need to learn how to build reliable systems without it.</description>
    </item>
    
    <item>
      <title>Consistent state</title>
      <link>https://exactly-once.github.io/posts/consistent-state/</link>
      <pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://exactly-once.github.io/posts/consistent-state/</guid>
      <description>In the previous post we talked about exactly-once processing looking at the endpoint from the outside. Here we will re-focus on an individual endpoint and see what exactly-once means for an endpoint&amp;rsquo;s state.
It&amp;rsquo;s not about the execution history Exactly-once spawned some heated debates in the past1 so let&amp;rsquo;s make sure we make it clear what it means in our context - or more importantly what it doesn&amp;rsquo;t. Here we talk about exactly-once processing not delivery, the two being quite different things.</description>
    </item>
    
    <item>
      <title>Sync-async boundary</title>
      <link>https://exactly-once.github.io/posts/sync-async-boundary/</link>
      <pubDate>Thu, 19 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://exactly-once.github.io/posts/sync-async-boundary/</guid>
      <description>If our experience in the IT industry has taught us anything it would be that drawing boundaries is the most important part of the design process. Boundaries are essential for understanding and communicating the design. The sync-async is an example of a boundary that is useful when designing distributed systems.
Purely sync The most popular technology for building synchronous systems is HTTP. Such systems often consist of multiple layers of HTTP endpoints.</description>
    </item>
    
    <item>
      <title>Consistent messaging</title>
      <link>https://exactly-once.github.io/posts/consistent-messaging/</link>
      <pubDate>Wed, 04 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://exactly-once.github.io/posts/consistent-messaging/</guid>
      <description>Modern messaging infrastructures offer delivery guarantees that make it non-trivial to build distributed systems. Robust solutions require a good understanding of what can and can&amp;rsquo;t happen and how that affects business level behavior.
This post looks at the main challenges from the system consistency perspective and sketches possible solutions.
A system We will assume that systems in focus consist of endpoints, each owning a distinct piece of state. Every endpoint processes input messages, modifying internal state and producing output messages.</description>
    </item>
    
  </channel>
</rss>